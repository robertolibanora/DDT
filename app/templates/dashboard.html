{% extends "base.html" %}

{% block title %}Dashboard DDT{% endblock %}

{% block header_title %}Dashboard DDT{% endblock %}

{% block extra_css %}
{% endblock %}

{% block header_extra %}
    <div class="header-actions">
        <div class="watchdog-indicator">
            <span class="watchdog-badge hidden" id="watchdog-badge" 
                  title="Clicca per aprire la coda documenti in attesa di elaborazione"
                  role="button"
                  tabindex="0">
                <span class="badge-count">0</span>
                <span class="badge-label">in attesa</span>
            </span>
        </div>
        <div class="last-update">
            Ultimo aggiornamento: <span id="last-update">--</span>
            <span class="refresh-indicator" id="refresh-indicator">
                <span class="spinner"></span>
            </span>
        </div>
    </div>
{% endblock %}

{% block messages %}
    <div id="error-message" class="message error hidden"></div>
    <!-- Banner backend down -->
    <div id="backend-down-banner" class="backend-down-banner hidden">
        <div class="backend-down-content">
            <div class="backend-down-icon">‚ö†Ô∏è</div>
            <div class="backend-down-text">
                <div class="backend-down-title">Connessione al server non disponibile</div>
                <div class="backend-down-subtitle">Riprovo automaticamente...</div>
            </div>
        </div>
    </div>
    <!-- Banner documenti in attesa -->
    <div id="pending-documents-banner" class="pending-documents-banner hidden">
        <div class="pending-banner-content">
            <div class="pending-banner-icon">‚ö†Ô∏è</div>
            <div class="pending-banner-text">
                <div class="pending-banner-title">Ci sono <span id="pending-count">0</span> documento<span id="pending-plural">i</span> in attesa di intervento</div>
                <div class="pending-banner-subtitle">Alcuni documenti DDT richiedono la tua attenzione per essere completati</div>
            </div>
            <button id="view-pending-btn" class="btn-pending-action" onclick="openWatchdogQueue()">
                Visualizza Documenti
            </button>
        </div>
    </div>
{% endblock %}

{% block content %}
    <!-- Sezione configurazione data cartella output -->
    <div id="output-date-config" class="output-date-config">
        <div class="output-date-content">
            <div class="output-date-info">
                <div class="output-date-icon">üìÅ</div>
                <div class="output-date-text">
                    <div class="output-date-label">Cartella di destinazione attiva</div>
                    <div class="output-date-value">
                        Cartella di destinazione: <span id="current-output-date">--</span>
                        <span class="output-date-status" id="output-date-status">(attiva)</span>
                        <span id="output-date-saving" class="output-date-saving hidden">
                            <span class="spinner-small"></span> Salvataggio...
                        </span>
                        <span id="output-date-saved" class="output-date-saved hidden">‚úÖ Salvato</span>
                        <span id="output-date-error" class="output-date-error hidden"></span>
                    </div>
                </div>
            </div>
            <button id="edit-output-date-btn" class="btn-edit-output-date" title="Modifica data cartella di destinazione">
                ‚úèÔ∏è Modifica Data
            </button>
        </div>
        
        <!-- Modal per modifica data -->
        <div id="output-date-modal" class="output-date-modal hidden">
            <div class="output-date-modal-content">
                <div class="output-date-modal-header">
                    <h3>Modifica Data Cartella di Destinazione</h3>
                    <button id="close-output-date-modal" class="output-date-modal-close">‚úï</button>
                </div>
                <div class="output-date-modal-body">
                    <p class="output-date-modal-warning">
                        ‚ö†Ô∏è <strong>Attenzione:</strong> La data che imposti verr√† usata per <strong>TUTTI</strong> i documenti processati da questo momento in poi.
                    </p>
                    <div class="form-group">
                        <label for="output-date-input">Cartella di destinazione (YYYY-MM-DD)</label>
                        <div class="output-date-input-wrapper">
                            <input type="date" id="output-date-input" required>
                        </div>
                        <small class="form-help">Tutti i documenti verranno salvati nella cartella con questa data</small>
                    </div>
                </div>
                <div class="output-date-modal-actions">
                    <button id="save-output-date-btn" class="btn btn-primary">Salva</button>
                    <button id="cancel-output-date-btn" class="btn btn-secondary">Annulla</button>
                </div>
            </div>
        </div>
    </div>

    <div id="stats">
        <div class="stat-item">
            <div class="stat-label">Totale DDT</div>
            <div class="stat-value" id="tot-ddt">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Totale Kg</div>
            <div class="stat-value" id="tot-kg">0.00</div>
        </div>
        <div class="stat-item stat-actions">
            <button id="clear-all-btn" class="btn btn-clear" title="Cancella tutti i DDT">
                Svuota DDT
            </button>
        </div>
    </div>

    <table>
        <thead>
            <tr>
                <th>Data</th>
                <th>Mittente</th>
                <th>Destinatario</th>
                <th>Numero Doc.</th>
                <th>Kg</th>
            </tr>
        </thead>
        <tbody id="table-body">
            <tr>
                <td colspan="5" class="loading">
                    <div class="spinner"></div> Caricamento dati...
                </td>
            </tr>
        </tbody>
    </table>
{% endblock %}

{% block scripts %}
    <script>
        // Gestione loader centralizzata con counter
        let loaderCounter = 0;
        let pollingActive = false;
        let pollingAbortController = null;
        let isPageVisible = true;
        
        let errorCount = 0;
        const MAX_ERRORS = 3;
        
        // Funzione helper per gestire loader
        function setLoaderActive(active) {
            const indicator = document.getElementById('refresh-indicator');
            if (!indicator) return;
            
            if (active) {
                loaderCounter++;
                indicator.classList.add('active');
            } else {
                loaderCounter = Math.max(0, loaderCounter - 1);
                if (loaderCounter === 0) {
                    indicator.classList.remove('active');
                }
            }
        }
        
        // Gestione banner backend down
        let backendDownBannerVisible = false;
        
        function showBackendDownBanner() {
            if (backendDownBannerVisible) return;
            const banner = document.getElementById('backend-down-banner');
            if (banner) {
                banner.classList.remove('hidden');
                backendDownBannerVisible = true;
            }
        }
        
        function hideBackendDownBanner() {
            if (!backendDownBannerVisible) return;
            const banner = document.getElementById('backend-down-banner');
            if (banner) {
                banner.classList.add('hidden');
                backendDownBannerVisible = false;
            }
        }
        
        // Error handler globali per rimuovere loader in caso di errori JS non gestiti
        window.addEventListener('error', (event) => {
            console.error('Errore JS non gestito:', event.error);
            loaderCounter = 0;
            setLoaderActive(false);
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promise rejection non gestita:', event.reason);
            loaderCounter = 0;
            setLoaderActive(false);
            
            // Se √® network error, mostra banner
            if (event.reason && event.reason.isNetworkError) {
                showBackendDownBanner();
            }
        });

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            errorCount++;
        }

        function hideError() {
            document.getElementById('error-message').classList.add('hidden');
            errorCount = 0;
        }

        function formatDate(dateStr) {
            if (!dateStr || dateStr === '1900-01-01') return '-';
            try {
                const [year, month, day] = dateStr.split('-');
                return `${day}/${month}/${year}`;
            } catch {
                return dateStr;
            }
        }

        function formatNumber(num) {
            const n = parseFloat(num);
            if (isNaN(n)) return '0,000';
            // Usa virgola come separatore decimale (formato italiano)
            return n.toFixed(3).replace('.', ',');
        }

        /**
         * Normalizza il numero documento rimuovendo suffissi testuali come "nuovo"
         * @param {string} numeroDoc - Numero documento da normalizzare
         * @returns {string} Numero documento pulito
         */
        function normalizeNumeroDocumento(numeroDoc) {
            if (!numeroDoc || typeof numeroDoc !== 'string') {
                return numeroDoc || '-';
            }
            
            // Rimuovi "nuovo" (case-insensitive) e spazi extra
            let normalized = numeroDoc.trim();
            
            // Rimuovi "nuovo" alla fine del testo (con o senza spazi)
            normalized = normalized.replace(/\s*nuovo\s*$/i, '');
            
            // Rimuovi "nuovo" all'inizio del testo (con o senza spazi)
            normalized = normalized.replace(/^\s*nuovo\s*/i, '');
            
            // Rimuovi spazi multipli e trim finale
            normalized = normalized.replace(/\s+/g, ' ').trim();
            
            return normalized || '-';
        }

        // Esponi refreshData globalmente per il modal
        window.refreshData = async function refreshData() {
            const tbody = document.getElementById("table-body");
            
            try {
                const data = await apiGet("/data");
                
                // Backend risponde ‚Üí nascondi banner
                hideBackendDownBanner();
                
                // REGOLA FERREA: Il backend garantisce sempre una struttura completa
                // Non facciamo controlli tipo if (!data) return che bloccano la UX
                // Normalizza data.rows a array vuoto se mancante o non valido
                const rows = Array.isArray(data?.rows) ? data.rows : [];
                
                // Se c'√® un errore nel backend ma ha ritornato struttura completa, logga ma continua
                if (data?.error) {
                    console.warn('Backend ha ritornato errore fallback:', data.error_message || data.error);
                    // Non mostriamo errore se il backend ha gestito il fallback correttamente
                    // Mostriamo solo se √® un errore critico
                }
                
                hideError();
                renderTable(rows);
                updateStats(rows);
                updateLastUpdateTime();
                
            } catch (error) {
                // Se √® network error, mostra banner backend down
                if (error.isNetworkError) {
                    showBackendDownBanner();
                } else {
                    console.error('Errore refresh dati:', error);
                }
                
                // In caso di errore, mostra tabella vuota con messaggio
                if (tbody) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" class="empty-state">
                                Errore durante il caricamento dei dati. Riprova pi√π tardi.
                            </td>
                        </tr>
                    `;
                }
                
                // Mostra statistiche a zero
                updateStats([]);
                
                if (!error.isNetworkError) {
                    if (errorCount < MAX_ERRORS) {
                        showError(`Errore durante il caricamento: ${error.message}`);
                    } else {
                        showError('Errore persistente nel caricamento dati. Controlla la connessione.');
                    }
                }
            } finally {
                // Rimuovi spinner iniziale se ancora presente (primo caricamento)
                if (tbody) {
                    const loadingRow = tbody.querySelector('.loading');
                    if (loadingRow) {
                        loadingRow.remove();
                    }
                }
            }
        }

        // Stato precedente per diff-based rendering deterministico
        let previousRowIds = new Set(); // Set di ID univoci delle righe esistenti
        let previousRowsData = []; // Dati completi delle righe precedenti
        let rowIdToElement = new Map(); // Mappa ID -> elemento DOM per aggiornamenti rapidi

        /**
         * Genera un ID univoco stabile per una riga basato su numero_documento + mittente + data
         * Questo ID √® deterministico e non cambia tra refresh
         */
        function getRowId(row) {
            const num = (row.numero_documento || '').trim();
            const mitt = (row.mittente || '').trim();
            const data = (row.data || '').trim();
            return `${num}|${mitt}|${data}`;
        }

        /**
         * Rendering deterministico: aggiunge SOLO nuove righe, mantiene posizioni esistenti
         * PRINCIPIO: Nessun documento deve riapparire una volta completato
         */
        function renderTable(rows) {
            const tbody = document.getElementById("table-body");
            
            if (rows.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" class="empty-state">
                            Nessun DDT presente. Carica un DDT per iniziare.
                        </td>
                    </tr>
                `;
                previousRowIds.clear();
                previousRowsData = [];
                rowIdToElement.clear();
                return;
            }
            
            // Genera ID per tutte le righe correnti
            const currentRowIds = new Set(rows.map(getRowId));
            
            // Se stesso contenuto (stessi ID), non fare nulla (evita re-render inutile)
            if (currentRowIds.size === previousRowIds.size && 
                [...currentRowIds].every(id => previousRowIds.has(id))) {
                return; // Nessun cambiamento, skip rendering
            }
            
            // Prima renderizzazione: crea tutte le righe
            if (previousRowIds.size === 0) {
                tbody.innerHTML = rows.map((row, index) => {
                    const rowId = getRowId(row);
                    const isNewest = index === 0;
                    const html = createTableRowHTML(row, isNewest, rowId);
                    previousRowIds.add(rowId);
                    return html;
                }).join('');
                
                // Salva riferimento agli elementi DOM
                rows.forEach((row, index) => {
                    const rowId = getRowId(row);
                    const tr = tbody.children[index];
                    if (tr) {
                        tr.dataset.rowId = rowId;
                        rowIdToElement.set(rowId, tr);
                    }
                });
                
                previousRowsData = rows;
                return;
            }
            
            // Diff-based: trova SOLO nuove righe da aggiungere
            const newRows = rows.filter(row => {
                const rowId = getRowId(row);
                return !previousRowIds.has(rowId);
            });
            
            // Rimuovi righe che non esistono pi√π (dovrebbe essere raro, ma gestiamolo)
            const removedRowIds = [...previousRowIds].filter(id => !currentRowIds.has(id));
            removedRowIds.forEach(rowId => {
                const element = rowIdToElement.get(rowId);
                if (element && element.parentNode) {
                    element.remove();
                }
                rowIdToElement.delete(rowId);
                previousRowIds.delete(rowId);
            });
            
            // Aggiungi SOLO nuove righe in cima con fade-in discreto
            if (newRows.length > 0) {
                newRows.forEach((row, index) => {
                    const rowId = getRowId(row);
                    const isNewest = index === 0; // Solo la prima nuova riga √® "newest"
                    const rowElement = createTableRow(row, isNewest, rowId);
                    
                    // Inserisci in cima alla tabella
                    if (tbody.firstChild) {
                        tbody.insertBefore(rowElement, tbody.firstChild);
                    } else {
                        tbody.appendChild(rowElement);
                    }
                    
                    // Salva riferimento
                    rowIdToElement.set(rowId, rowElement);
                    previousRowIds.add(rowId);
                    
                    // Animazione fade-in discreto (200-300ms come richiesto)
                    requestAnimationFrame(() => {
                        rowElement.style.opacity = '1';
                        rowElement.style.transform = 'translateY(0)';
                    });
                });
                
                // Mostra toast notification per nuovo documento (solo se non √® il primo caricamento)
                if (previousRowsData.length > 0 && newRows.length > 0) {
                    const newestRow = newRows[0];
                    const numeroDocNormalized = normalizeNumeroDocumento(newestRow.numero_documento || 'DDT');
                    showToast({
                        type: 'success',
                        message: `Documento salvato: ${numeroDocNormalized}`,
                        duration: 3000
                    });
                }
            }
            
            // Aggiorna stato precedente
            previousRowsData = rows;
        }

        /**
         * Crea elemento DOM per una nuova riga con animazione fade-in
         */
        function createTableRow(row, isNewest, rowId) {
            const tr = document.createElement('tr');
            tr.dataset.rowId = rowId; // Salva ID per riferimento futuro
            tr.className = isNewest ? 'newest-row fade-in-row' : '';
            tr.style.opacity = '0';
            tr.style.transform = 'translateY(-10px)';
            tr.style.transition = 'opacity 0.25s ease, transform 0.25s ease'; // 250ms per essere discreto
            
            const badges = getRowBadges(row, isNewest);
            const kg = formatNumber(row.totale_kg);
            const numeroDocRaw = row.numero_documento || '-';
            const numeroDoc = escapeHtml(normalizeNumeroDocumento(numeroDocRaw));
            const mittente = escapeHtml(row.mittente || '');
            
            tr.innerHTML = `
                <td>${formatDate(row.data)}</td>
                <td>${mittente || '-'}</td>
                <td>${escapeHtml(row.destinatario || '-')}</td>
                <td>${numeroDoc}${badges}</td>
                <td>${kg}</td>
            `;
            
            return tr;
        }

        /**
         * Crea HTML per una riga (prima renderizzazione)
         */
        function createTableRowHTML(row, isNewest, rowId) {
            const badges = getRowBadges(row, isNewest);
            const kg = formatNumber(row.totale_kg);
            const numeroDocRaw = row.numero_documento || '-';
            const numeroDoc = escapeHtml(normalizeNumeroDocumento(numeroDocRaw));
            const mittente = escapeHtml(row.mittente || '');
            const rowClass = isNewest ? 'newest-row' : '';
            
            return `
                <tr class="${rowClass}" data-row-id="${escapeHtml(rowId)}">
                    <td>${formatDate(row.data)}</td>
                    <td>${mittente || '-'}</td>
                    <td>${escapeHtml(row.destinatario || '-')}</td>
                    <td>${numeroDoc}${badges}</td>
                    <td>${kg}</td>
                </tr>
            `;
        }

        /**
         * Genera badge per una riga basato su stato e timestamp
         * Badge "Nuovo" solo per documenti < 2h (fade-out automatico)
         */
        function getRowBadges(row, isNewest) {
            let badges = '';
            
            // Badge "Nuovo" solo per la prima riga (pi√π recente) e solo se < 2h
            if (isNewest) {
                // Nota: senza timestamp nel JSON, assumiamo che la prima riga sia sempre "nuova"
                // In futuro si pu√≤ aggiungere timestamp al JSON Excel
                badges += '<span class="badge badge-new" title="Documento aggiunto di recente">Nuovo</span>';
            }
            
            // Badge "Errore" se presente (in futuro si pu√≤ aggiungere campo status al JSON)
            // Per ora non disponibile senza file_hash nel JSON
            
            return badges;
        }

        function updateStats(rows) {
            const totalDDT = rows.length;
            let totalKg = 0;
            
            rows.forEach(row => {
                const kg = parseFloat(row.totale_kg || 0);
                if (!isNaN(kg)) {
                    totalKg += kg;
                }
            });
            
            document.getElementById("tot-ddt").textContent = totalDDT;
            document.getElementById("tot-kg").textContent = formatNumber(totalKg);
            
            // Mostra/nascondi pulsante svuota in base ai dati presenti
            const clearBtn = document.getElementById('clear-all-btn');
            if (clearBtn) {
                const statActions = clearBtn.closest('.stat-actions');
                if (statActions) {
                    if (totalDDT === 0) {
                        statActions.style.display = 'none';
                    } else {
                        statActions.style.display = 'flex';
                    }
                }
            }
        }

        function updateLastUpdateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('it-IT', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('last-update').textContent = timeStr;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Funzione per svuotare tutti i DDT con prevenzione doppi submit
        async function clearAllDDT() {
            const clearBtn = document.getElementById('clear-all-btn');
            
            // Prevenzione doppi submit: se gi√† in loading, ignora
            if (clearBtn && (clearBtn.disabled || clearBtn.dataset.loading === 'true')) {
                return;
            }
            
            // Conferma prima di cancellare
            const confirmed = confirm('‚ö†Ô∏è ATTENZIONE!\n\nStai per cancellare TUTTI i DDT dal database.\nQuesta operazione non pu√≤ essere annullata.\n\nSei sicuro di voler continuare?');
            
            if (!confirmed) {
                return;
            }
            
            const originalText = clearBtn.textContent;
            
            try {
                clearBtn.disabled = true;
                clearBtn.dataset.loading = 'true';
                clearBtn.textContent = '‚è≥ Cancellazione...';
                
                const data = await apiPost('/data/clear');
                
                // Mostra messaggio di successo
                showError(`${data.message || 'Tutti i DDT sono stati cancellati con successo'}`);
                setTimeout(() => hideError(), 5000);
                
                // Ricarica i dati
                await refreshData();
                
            } catch (error) {
                // Log solo se non √® network error
                if (!error.isNetworkError) {
                    console.error('Errore cancellazione:', error);
                }
                showError(`Errore: ${error.message}`);
            } finally {
                clearBtn.disabled = false;
                clearBtn.dataset.loading = 'false';
                clearBtn.textContent = originalText;
            }
        }
        
        // Aggiungi event listener al pulsante
        document.getElementById('clear-all-btn').addEventListener('click', clearAllDDT);

        // Gestione data cartella output
        let currentOutputDate = null;
        
        /**
         * Carica la data di output corrente dalla configurazione globale.
         * REGOLA FERREA: Non blocca mai la UX, anche in caso di errore.
         */
        async function loadOutputDate() {
            try {
                const data = await apiGet('/api/config/output-date');
                
                // Il backend garantisce sempre una struttura completa
                // Usa data.output_date anche se success √® false (fallback)
                const outputDate = data?.output_date || "";
                
                if (outputDate) {
                    currentOutputDate = outputDate;
                    const dateEl = document.getElementById('current-output-date');
                    if (dateEl) {
                        try {
                            // Converti da gg-mm-yyyy a formato leggibile
                            const [day, month, year] = outputDate.split('-');
                            if (day && month && year) {
                                dateEl.textContent = `${day}/${month}/${year}`;
                            } else {
                                dateEl.textContent = outputDate || '--';
                            }
                        } catch (e) {
                            dateEl.textContent = outputDate || '--';
                        }
                    }
                } else {
                    // Se non c'√® data, mostra placeholder
                    const dateEl = document.getElementById('current-output-date');
                    if (dateEl) {
                        dateEl.textContent = '--';
                    }
                }
                
                // Log warning solo se c'√® un errore reale (non fallback gestito)
                if (data?.error) {
                    console.warn('Errore caricamento data output (fallback gestito):', data.error_message || data.error);
                }
            } catch (error) {
                // Se 401, utente non autenticato, non fare nulla
                if (error.message && error.message.includes('Sessione scaduta')) {
                    return;
                }
                console.error('Errore caricamento data output:', error);
                // REGOLA FERREA: Non bloccare la UX, mostra solo placeholder
                const dateEl = document.getElementById('current-output-date');
                if (dateEl) {
                    dateEl.textContent = '--';
                }
            }
        }
        
        /**
         * Mostra modal per modifica data output
         */
        function showOutputDateModal() {
            const modal = document.getElementById('output-date-modal');
            const input = document.getElementById('output-date-input');
            
            if (modal && input && currentOutputDate) {
                // Converti da gg-mm-yyyy a YYYY-MM-DD per input date
                const [day, month, year] = currentOutputDate.split('-');
                const isoDate = `${year}-${month}-${day}`;
                input.value = isoDate;
                
                modal.classList.remove('hidden');
                input.focus();
            }
        }
        
        /**
         * Nascondi modal per modifica data output
         */
        function hideOutputDateModal() {
            const modal = document.getElementById('output-date-modal');
            const input = document.getElementById('output-date-input');
            const savingEl = document.getElementById('output-date-saving');
            const savedEl = document.getElementById('output-date-saved');
            const errorEl = document.getElementById('output-date-error');
            const statusEl = document.getElementById('output-date-status');
            const saveBtn = document.getElementById('save-output-date-btn');
            
            if (modal) {
                modal.classList.add('hidden');
            }
            
            // Reset stati quando si chiude il modal
            if (input) input.disabled = false;
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Salva';
            }
            if (savingEl) savingEl.classList.add('hidden');
            if (savedEl) savedEl.classList.add('hidden');
            if (errorEl) errorEl.classList.add('hidden');
            if (statusEl) statusEl.classList.remove('hidden');
        }
        
        /**
         * Salva nuova data output con feedback visivo migliorato e prevenzione doppi submit
         */
        async function saveOutputDate() {
            const saveBtn = document.getElementById('save-output-date-btn');
            
            // Prevenzione doppi submit: se gi√† in loading, ignora
            if (saveBtn && (saveBtn.disabled || saveBtn.dataset.loading === 'true')) {
                return;
            }
            
            const input = document.getElementById('output-date-input');
            if (!input || !input.value) {
                // Mostra errore inline invece di alert
                const errorEl = document.getElementById('output-date-error');
                if (errorEl) {
                    errorEl.textContent = '‚ö†Ô∏è Seleziona una data';
                    errorEl.classList.remove('hidden');
                    setTimeout(() => errorEl.classList.add('hidden'), 3000);
                }
                return;
            }
            
            // Converti da YYYY-MM-DD a gg-mm-yyyy
            const isoDate = input.value;
            const [year, month, day] = isoDate.split('-');
            const dateStr = `${day}-${month}-${year}`;
            
            const inputWrapper = input.closest('.output-date-input-wrapper');
            const savingEl = document.getElementById('output-date-saving');
            const savedEl = document.getElementById('output-date-saved');
            const errorEl = document.getElementById('output-date-error');
            const statusEl = document.getElementById('output-date-status');
            
            // Reset stati precedenti
            if (savedEl) savedEl.classList.add('hidden');
            if (errorEl) errorEl.classList.add('hidden');
            
            // Disabilita input e mostra spinner (prevenzione doppi submit)
            input.disabled = true;
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.dataset.loading = 'true';
                saveBtn.textContent = 'Salvataggio...';
            }
            if (savingEl) savingEl.classList.remove('hidden');
            if (statusEl) statusEl.classList.add('hidden');
            
            try {
                // Usa PUT con JSON invece di POST con FormData
                const data = await apiPut('/api/config/output-date', { output_date: dateStr });
                
                if (data.success) {
                    // Aggiorna visualizzazione
                    currentOutputDate = dateStr;
                    await loadOutputDate();
                    
                    // Nascondi spinner, mostra badge "Salvato"
                    if (savingEl) savingEl.classList.add('hidden');
                    if (savedEl) {
                        savedEl.classList.remove('hidden');
                        // Rimuovi badge dopo 3 secondi
                        setTimeout(() => {
                            savedEl.classList.add('hidden');
                            if (statusEl) statusEl.classList.remove('hidden');
                        }, 3000);
                    }
                    
                    // Riabilita input
                    input.disabled = false;
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.dataset.loading = 'false';
                        saveBtn.textContent = 'Salva';
                    }
                    
                    // Chiudi modal dopo breve delay per mostrare feedback
                    setTimeout(() => {
                        hideOutputDateModal();
                    }, 1500);
                } else {
                    throw new Error(data.detail || 'Errore durante il salvataggio');
                }
            } catch (error) {
                // Log solo se non √® network error
                if (!error.isNetworkError) {
                    console.error('Errore salvataggio data output:', error);
                }
                
                // Nascondi spinner
                if (savingEl) savingEl.classList.add('hidden');
                
                // Mostra errore inline (NON alert)
                if (errorEl) {
                    errorEl.textContent = `‚ùå ${error.message}`;
                    errorEl.classList.remove('hidden');
                }
                
                // Riabilita input
                input.disabled = false;
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.dataset.loading = 'false';
                    saveBtn.textContent = 'Salva';
                }
                if (statusEl) statusEl.classList.remove('hidden');
            }
        }
        
        // Setup event listeners per gestione data output
        document.getElementById('edit-output-date-btn')?.addEventListener('click', showOutputDateModal);
        document.getElementById('close-output-date-modal')?.addEventListener('click', hideOutputDateModal);
        document.getElementById('cancel-output-date-btn')?.addEventListener('click', hideOutputDateModal);
        document.getElementById('save-output-date-btn')?.addEventListener('click', saveOutputDate);
        
        // Chiudi modal con ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('output-date-modal');
                if (modal && !modal.classList.contains('hidden')) {
                    hideOutputDateModal();
                }
            }
        });
        
        // Carica data output solo dopo DOMContentLoaded e api.js caricato
        document.addEventListener('DOMContentLoaded', () => {
            loadOutputDate();
        });

        // Gestione visibilit√† pagina per sospendere polling
        document.addEventListener('visibilitychange', () => {
            const wasVisible = isPageVisible;
            isPageVisible = !document.hidden;
            
            if (!wasVisible && isPageVisible) {
                // Pagina torna visibile: riparti polling con refresh immediato
                console.log('Pagina visibile, riavvio polling...');
                startPolling();
            } else if (wasVisible && !isPageVisible) {
                // Pagina nascosta: sospendi polling
                console.log('Pagina nascosta, sospendo polling...');
                stopPolling();
            }
        });

        // Gestione banner documenti in attesa
        let pendingDocumentsCount = 0;
        
        /**
         * Aggiorna il banner dei documenti in attesa
         * Mostra il banner solo se ci sono documenti in attesa (QUEUED, PROCESSING, READY_FOR_REVIEW, STUCK)
         * REGOLA FERREA: Non blocca mai la UX, anche in caso di errore.
         */
        async function updatePendingDocumentsBanner() {
            try {
                // REGOLA FERREA: Il backend garantisce sempre una struttura completa
                const data = await apiGet('/api/pending-documents-count');
                
                // Backend risponde ‚Üí nascondi banner
                hideBackendDownBanner();
                
                // Normalizza count a 0 se mancante o non valido
                pendingDocumentsCount = (data?.count !== undefined && data.count !== null) ? parseInt(data.count) || 0 : 0;
                
                const banner = document.getElementById('pending-documents-banner');
                const countEl = document.getElementById('pending-count');
                const pluralEl = document.getElementById('pending-plural');
                
                if (banner && countEl && pluralEl) {
                    if (pendingDocumentsCount > 0) {
                        // Mostra banner
                        countEl.textContent = pendingDocumentsCount;
                        pluralEl.textContent = pendingDocumentsCount === 1 ? 'o' : 'i';
                        banner.classList.remove('hidden');
                    } else {
                        // Nascondi banner (stato normale: nessun documento in attesa)
                        banner.classList.add('hidden');
                    }
                }
                
                // Log warning solo se c'√® un errore reale (non fallback gestito)
                if (data?.error) {
                    console.warn('Errore aggiornamento banner (fallback gestito):', data.error_message || data.error);
                }
            } catch (error) {
                // Se √® network error, mostra banner backend down (non logga)
                if (error.isNetworkError) {
                    showBackendDownBanner();
                } else {
                    console.error('Errore aggiornamento banner documenti in attesa:', error);
                }
                // REGOLA FERREA: In caso di errore, nascondi il banner per evitare confusione
                // Non bloccare la UX
                const banner = document.getElementById('pending-documents-banner');
                if (banner) {
                    banner.classList.add('hidden');
                }
                // Reset count a 0 per sicurezza
                pendingDocumentsCount = 0;
            }
        }
        
        // Controlla coda watchdog per nuovi PDF (UX migliorata)
        let lastProcessedQueueId = null;
        let lastQueueCount = 0;
        
        async function checkWatchdogQueue() {
            if (!isPageVisible) return;
            
            // Non controllare se il modal √® gi√† aperto
            const modal = document.getElementById('preview-modal');
            if (modal && !modal.classList.contains('hidden')) {
                return;
            }
            
            try {
                // REGOLA FERREA: Il backend garantisce sempre una struttura completa
                const data = await apiGet('/api/watchdog-queue');
                
                // Backend risponde ‚Üí nascondi banner
                hideBackendDownBanner();
                
                // Normalizza items a array vuoto se mancante o non valido
                const items = Array.isArray(data?.items) ? data.items : [];
                const queueCount = items.length;
                
                // Aggiorna badge watchdog (solo se count > 0)
                // PRINCIPIO: Eventi ignorati (documento gi√† FINALIZED) ‚Üí SILENZIO totale
                updateWatchdogBadge(queueCount);
                
                // Se ci sono nuovi elementi, mostra toast notification discreta
                // PRINCIPIO: Nessun modal automatico, solo notifica non invasiva
                if (queueCount > 0 && queueCount > lastQueueCount) {
                    const newItem = items.find(i => i.id !== lastProcessedQueueId) || items[0];
                    
                    if (newItem && newItem.id !== lastProcessedQueueId) {
                        lastProcessedQueueId = newItem.id;
                        
                        // Toast notification discreta con azione opzionale
                        showToast({
                            type: 'info',
                            message: `Nuovo documento rilevato: ${newItem.file_name || 'DDT'}`,
                            action: 'Apri anteprima',
                                actionCallback: () => {
                                if (window.previewModal && newItem.extracted_data) {
                                    window.previewModal.show(
                                        newItem.extracted_data,
                                        newItem.pdf_base64,
                                        newItem.file_hash,
                                        newItem.file_name,
                                        newItem.extraction_mode || null,
                                        newItem.suggest_create_layout || false,
                                        newItem.has_layout_model !== undefined ? newItem.has_layout_model : null,
                                        newItem.ai_fallback_used || false,
                                        newItem.ai_fallback_fields || []
                                    );
                                } else if (window.previewModal) {
                                    // Mostra modal anche senza dati estratti (QUEUED/PROCESSING)
                                    window.previewModal.show(
                                        null, // extractedData
                                        null, // pdfBase64
                                        newItem.file_hash,
                                        newItem.file_name,
                                        null, // extractionMode
                                        false, // suggestCreateLayout
                                        null,  // hasLayoutModel
                                        false, // aiFallbackUsed
                                        []     // aiFallbackFields
                                    );
                                }
                            },
                            duration: 8000
                        });
                    }
                }
                
                lastQueueCount = queueCount;
                
                // Log warning solo se c'√® un errore reale (non fallback gestito)
                if (data?.error) {
                    console.warn('Errore controllo coda watchdog (fallback gestito):', data.error_message || data.error);
                }
            } catch (error) {
                // Se √® network error, mostra banner backend down
                if (error.isNetworkError) {
                    showBackendDownBanner();
                } else {
                    console.error('Errore controllo coda watchdog:', error);
                }
                // REGOLA FERREA: Non bloccare la UX, nascondi badge e reset count
                updateWatchdogBadge(0);
                lastQueueCount = 0;
            }
        }

        /**
         * Aggiorna badge watchdog con contatore documenti in attesa
         * PRINCIPIO: Visibile solo se count > 0, click apre coda manualmente
         */
        function updateWatchdogBadge(count) {
            const badge = document.getElementById('watchdog-badge');
            const badgeCount = badge ? badge.querySelector('.badge-count') : null;
            
            if (!badge || !badgeCount) return;
            
            if (count > 0) {
                badgeCount.textContent = count;
                badge.classList.remove('hidden');
                
                // Aggiungi event listener per click (solo una volta)
                if (!badge.dataset.listenerAdded) {
                    badge.addEventListener('click', openWatchdogQueue);
                    badge.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            openWatchdogQueue();
                        }
                    });
                    badge.dataset.listenerAdded = 'true';
                }
            } else {
                badge.classList.add('hidden');
            }
        }

        /**
         * Apre la coda watchdog manualmente quando l'utente clicca sul badge
         * PRINCIPIO: Nessun modal automatico, solo su richiesta utente
         * REGOLA FERREA: Non blocca mai la UX, anche in caso di errore.
         */
        async function openWatchdogQueue() {
            if (!window.previewModal) {
                showToast({
                    type: 'warning',
                    message: 'Sistema di anteprima non disponibile',
                    duration: 3000
                });
                return;
            }
            
            try {
                // REGOLA FERREA: Il backend garantisce sempre una struttura completa
                const data = await apiGet('/api/watchdog-queue');
                
                // Normalizza items a array vuoto se mancante o non valido
                const items = Array.isArray(data?.items) ? data.items : [];
                
                if (items.length === 0) {
                    showToast({
                        type: 'info',
                        message: 'Nessun documento in attesa',
                        duration: 3000
                    });
                    return;
                }
                
                // Mostra il primo documento della coda
                const item = items[0];
                // Gestisce il caso in cui extracted_data non √® disponibile (QUEUED/PROCESSING)
                window.previewModal.show(
                    item.extracted_data || null, // Gestisce undefined/null
                    item.pdf_base64 || null,
                    item.file_hash,
                    item.file_name,
                    item.extraction_mode || null,
                    item.suggest_create_layout || false,
                    item.has_layout_model !== undefined ? item.has_layout_model : null,
                    item.ai_fallback_used || false,
                    item.ai_fallback_fields || []
                );
                
                // Log warning solo se c'√® un errore reale (non fallback gestito)
                if (data?.error) {
                    console.warn('Errore apertura coda watchdog (fallback gestito):', data.error_message || data.error);
                }
            } catch (error) {
                console.error('Errore apertura coda watchdog:', error);
                showToast({
                    type: 'error',
                    message: 'Errore durante il caricamento della coda',
                    duration: 5000
                });
            }
        }

        /**
         * Toast notification system non invasivo
         * PRINCIPIO: Feedback chiaro ma NON invasivo, auto-dismiss 5-8s
         * Posizione: top-right, tipi: info, success, warning, error
         */
        function showToast(options) {
            const { type = 'info', message, action, actionCallback, duration = 5000 } = options;
            
            // Crea container toast se non esiste
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.className = 'toast-container';
                document.body.appendChild(toastContainer);
            }
            
            // Crea toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'polite');
            
            toast.innerHTML = `
                <div class="toast-content">
                    <span class="toast-message">${escapeHtml(message)}</span>
                    ${action && actionCallback ? `<button class="toast-action" type="button">${escapeHtml(action)}</button>` : ''}
                </div>
                <button class="toast-close" type="button" aria-label="Chiudi notifica">√ó</button>
            `;
            
            // Event listener per chiusura
            const closeBtn = toast.querySelector('.toast-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    toast.classList.remove('toast-show');
                    setTimeout(() => toast.remove(), 300);
                });
            }
            
            // Event listener per azione
            if (action && actionCallback) {
                const actionBtn = toast.querySelector('.toast-action');
                if (actionBtn) {
                    actionBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        actionCallback();
                        toast.classList.remove('toast-show');
                        setTimeout(() => toast.remove(), 300);
                    });
                }
            }
            
            toastContainer.appendChild(toast);
            
            // Animazione fade-in discreta
            requestAnimationFrame(() => {
                toast.classList.add('toast-show');
            });
            
            // Auto-remove dopo duration (5-8s come richiesto)
            const autoRemoveTimeout = setTimeout(() => {
                toast.classList.remove('toast-show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, duration);
            
            // Pausa auto-remove su hover (UX migliorata)
            toast.addEventListener('mouseenter', () => {
                clearTimeout(autoRemoveTimeout);
            });
            
            toast.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    toast.classList.remove('toast-show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }, duration);
            });
        }

        // Funzione helper per sleep
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        /**
         * Checklist go-live automatica
         */
        async function runGoLiveChecks() {
            const checks = {
                apiJsLoaded: typeof apiGet !== 'undefined',
                apiGetDefined: typeof apiGet === 'function',
                healthcheckOk: false,
                pollingActive: pollingActive,
                loaderOff: loaderCounter === 0
            };
            
            // Verifica healthcheck
            try {
                const healthData = await apiGet('/api/health');
                checks.healthcheckOk = healthData.status === 'ok';
            } catch (error) {
                checks.healthcheckOk = false;
            }
            
            // Log risultati
            const allOk = Object.values(checks).every(v => v === true);
            
            if (!allOk) {
                console.warn('[GO-LIVE CHECK] Alcuni controlli falliti:', checks);
                
                // Banner non bloccante se healthcheck fallisce
                if (!checks.healthcheckOk) {
                    showBackendDownBanner();
                }
            } else {
                console.log('[GO-LIVE CHECK] Tutti i controlli OK');
            }
            
            return checks;
        }
        
        // Esegui checklist dopo caricamento completo
        if (document.readyState === 'complete') {
            setTimeout(runGoLiveChecks, 2000);
        } else {
            window.addEventListener('load', () => {
                setTimeout(runGoLiveChecks, 2000);
            });
        }
        
        // Funzione per eseguire tutte le chiamate API in sequenza
        async function refreshAll() {
            if (!isPageVisible) return;
            
            // Set loader ON all'inizio del ciclo
            setLoaderActive(true);
            
            try {
                // Esegui chiamate IN SEQUENZA (una alla volta)
                await refreshData();
                await checkWatchdogQueue();
                await updatePendingDocumentsBanner();
            } catch (error) {
                // Errori gi√† gestiti nelle singole funzioni, log qui per sicurezza
                console.error('Errore durante refreshAll:', error);
            } finally {
                // Set loader OFF sempre alla fine
                setLoaderActive(false);
            }
        }
        
        // Loop async sequenziale per polling intelligente
        async function pollingLoop() {
            while (pollingActive && isPageVisible) {
                try {
                    await refreshAll();
                    // Attendi 5 secondi prima del prossimo ciclo
                    await sleep(5000);
                } catch (error) {
                    // Errore nel loop stesso (non nelle fetch)
                    console.error('Errore nel polling loop:', error);
                    setLoaderActive(false);
                    // Attendi prima di riprovare
                    await sleep(5000);
                }
            }
        }
        
        // Avvia polling
        function startPolling() {
            if (pollingActive) return;
            
            pollingActive = true;
            pollingAbortController = new AbortController();
            pollingLoop().catch(error => {
                console.error('Errore fatale nel polling loop:', error);
                setLoaderActive(false);
            });
        }
        
        // Ferma polling
        function stopPolling() {
            pollingActive = false;
            if (pollingAbortController) {
                pollingAbortController.abort();
                pollingAbortController = null;
            }
            setLoaderActive(false);
        }
        
        // Pulisci polling quando la pagina viene chiusa
        window.addEventListener('beforeunload', () => {
            stopPolling();
        });
        
        // Carica inizialmente solo dopo che il DOM √® pronto e api.js √® caricato
        document.addEventListener('DOMContentLoaded', () => {
            // Carica output date una sola volta all'avvio
            loadOutputDate();
            
            // Refresh iniziale
            refreshAll().then(() => {
                // Avvia polling dopo il primo refresh
                startPolling();
            }).catch(error => {
                console.error('Errore refresh iniziale:', error);
                setLoaderActive(false);
                // Avvia comunque il polling
                startPolling();
            });
        });
    </script>
{% endblock %}
